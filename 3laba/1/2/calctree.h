/*
CalcTree10. В текстовом файле с именем FN1 дано арифметическое выражение в инфиксной
форме. В выражении могут использоваться операции: сложение(+), вычитание(-), умножение(*),
деление нацело(/), остаток от деления(%), возведение в степень(^), а так же целые числа из промежутка [1; 30] и переменная x. 
Для операции возведения в степень показатель степени неотрицательное целое число. Постройте дерево выражения. 
После этого вычислите значение выражения при заданном значении переменной x и выведите результат в текстовый файл с именем FN2.
Преобразуйте дерево, заменив все поддеревья вида x*A на A*x, где A - некоторое поддерево, а x - переменная.
Распечатайте дерево после преобразования в файл FN2 используя многострочный формат, в котором дерево положено на бок. 
Каждый уровень дерева выводите в 4-х позициях и используйте выравнивание по правому краю. 
При наличии нескольких подряд идущих одинаковых операций дерево должно строиться по правилу: операции одинакового приоритета 
вычисляются по порядку слева направо. Иными словами, выражение 2+3+4+5, например, должно трактоваться как ((2+3)+4)+5, и не может 
трактоваться как (2+3)+(4+5) или 2+(3+(4+5)). Результаты всех вычислений, включая промежуточные, принадлежат типу int.
*/

#ifndef CALC_TREE_H
#define CALC_TREE_H

#include <string>
#include <vector>
#include <fstream>


/**
 * @struct Node
 * @brief Представляет узел дерева выражения.
 */
struct Node {
    std::string value;
    Node *left;
    Node *right;

    /**
     * @brief Конструктор узла дерева.
     * @param val Значение узла (число, оператор или переменная).
     */
    Node(std::string val);
};

/**
 * @brief Определяет приоритет оператора.
 * @param op Строковое представление оператора.
 * @return Целое число, представляющее приоритет оператора (чем выше число, тем выше приоритет).
 */
int Get_priority(const std::string& op);

/**
 * @brief Проверяет, является ли строка целым числом.
 * @param s Строка для проверки.
 * @return true, если строка является целым числом, false в противном случае.
 */
bool Is_number(const std::string& s);

/**
 * @brief Проверяет, является ли строка арифметическим оператором.
 * @param s Строка для проверки.
 * @return true, если строка является оператором, false в противном случае.
 */
bool Is_operator(const std::string& s);

/**
 * @brief Выполняет лексический анализ арифметического выражения.
 * @param expression Строка с арифметическим выражением в инфиксной форме.
 * @return Вектор строк, представляющих токены выражения.
 */
std::vector<std::string> Tokenize(const std::string& expression);

/**
 * @brief Строит дерево выражения из постфиксной нотации.
 * @param postfix_tokens Вектор строк с токенами в постфиксной форме.
 * @return Указатель на корень построенного дерева выражения.
 */
Node* Build_expression_tree(std::vector<std::string>& postfix_tokens);

/**
 * @brief Преобразует инфиксную нотацию в постфиксную (обратная польская запись).
 * @param infix_tokens Вектор строк с токенами в инфиксной форме.
 * @return Вектор строк с токенами в постфиксной форме.
 */
std::vector<std::string> Infix_to_postfix(const std::vector<std::string>& infix_tokens);

/**
 * @brief Вычисляет значение поддерева выражения.
 * @param node Указатель на корень поддерева.
 * @param x_value Значение переменной x.
 * @return Целочисленный результат вычисления поддерева.
 */
int Evaluate(Node* node, int x_value);

/**
 * @brief Преобразует дерево, заменяя поддеревья вида x * A на A * x.
 * @param node Указатель на корень дерева (или поддерева).
 * @return Указатель на корень преобразованного дерева (или поддерева).
 */
Node* Transform_tree(Node* node);

/**
 * @brief Вспомогательная функция для рекурсивной печати дерева.
 * @param node Указатель на текущий узел дерева.
 * @param level Текущий уровень дерева.
 * @param outfile Поток вывода в файл.
 */
void Print_tree_helper(Node* node, int level, std::ofstream& outfile);

/**
 * @brief Печатает дерево выражения в файл в многострочном формате.
 * @param root Указатель на корень дерева.
 * @param outfile Поток вывода в файл.
 */
void Print_tree(Node* root, std::ofstream& outfile);

/**
 * @brief Освобождает память, занятую деревом выражения (рекурсивно).
 * @param node Указатель на корень дерева (или поддерева).
 */
void Delete_tree(Node* node);

#endif // CALC_TREE_H
